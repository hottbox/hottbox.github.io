

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>hottbox.algorithms.classification.ensemble_learning &mdash; HOTTBOX: Higher Order Tensors ToolBox</title>
  

  
  
    <link rel="shortcut icon" href="../../../../_static/hottbox_favicon-48x48.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html">
          

          
            
            <img src="../../../../_static/hottbox_logo_2.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installing HOTTBOX</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../installation.html#running-tests">Running tests</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/modules.html">HOTTBOX API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/hottbox.core.html">Core Structures and Operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.core.html#module-hottbox.core.structures">Tensor Representations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.Tensor.html">Tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.TensorCPD.html">TensorCPD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.TensorTKD.html">TensorTKD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.TensorTT.html">TensorTT</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.core.html#module-hottbox.core.operations">Multi-linear Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.unfold.html">unfold</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.fold.html">fold</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.kolda_unfold.html">kolda_unfold</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.kolda_fold.html">kolda_fold</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.mode_n_product.html">mode_n_product</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.kronecker.html">kronecker</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.hadamard.html">hadamard</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.khatri_rao.html">khatri_rao</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.core.sampled_khatri_rao.html">sampled_khatri_rao</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/hottbox.algorithms.html">Algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.algorithms.html#module-hottbox.algorithms.decomposition">Tensor Decomposition Algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.algorithms.decomposition.CPD.html">CPD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.algorithms.decomposition.RandomisedCPD.html">RandomisedCPD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.algorithms.decomposition.Parafac2.html">Parafac2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.algorithms.decomposition.HOSVD.html">HOSVD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.algorithms.decomposition.HOOI.html">HOOI</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.algorithms.decomposition.TTSVD.html">TTSVD</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.algorithms.html#module-hottbox.algorithms.decomposition.fusion">Data Fusion Algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.algorithms.decomposition.fusion.CMTF.html">CMTF</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.algorithms.html#module-hottbox.algorithms.classification">Multi-linear Classification Algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.algorithms.classification.LSSTM.html">LSSTM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.algorithms.classification.TelVI.html">TelVI</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.algorithms.classification.TelVAC.html">TelVAC</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/hottbox.pdtools.html">Pandas Integration Tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.pdtools.html#module-hottbox.pdtools">Conversion Utilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.pdtools.pd_to_tensor.html">pd_to_tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.pdtools.tensor_to_pd.html">tensor_to_pd</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/hottbox.metrics.html">Metrics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.metrics.html#module-hottbox.metrics">Approximation scores</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.metrics.mse.html">mse</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.metrics.rmse.html">rmse</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.metrics.mape.html">mape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.metrics.residual_rel_error.html">residual_rel_error</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.metrics.html#classification-scores">Classification scores</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/hottbox.rank.html">Multi-dimensional Rank</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.rank.html#module-hottbox.rank">Rank Estimation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.rank.rankest.html">rankest</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.rank.mlrank.html">mlrank</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/hottbox.datasets.html">Datasets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.datasets.html#module-hottbox.datasets">Synthetic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.datasets.make_clusters.html">make_clusters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/hottbox.errors.html">Custom Exceptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.errors.html#module-hottbox.errors">Errors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.errors.TensorStateError.html">TensorStateError</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.errors.TensorModeError.html">TensorModeError</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.errors.TensorShapeError.html">TensorShapeError</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.errors.TensorTopologyError.html">TensorTopologyError</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.errors.StateError.html">StateError</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.errors.ModeError.html">ModeError</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/hottbox.utils.html">Utility Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.utils.html#module-hottbox.utils.generation">Generation of N-dimensional arrays</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.toeplitz_matrix.html">toeplitz_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.hankel_matrix.html">hankel_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.quick_tensor.html">quick_tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.quick_tensorcpd.html">quick_tensorcpd</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.quick_tensortkd.html">quick_tensortkd</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.quick_tensortt.html">quick_tensortt</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.dense_tensor.html">dense_tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.super_diagonal_tensor.html">super_diagonal_tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.super_symmetric_tensor.html">super_symmetric_tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.sparse_tensor.html">sparse_tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.super_diag_tensor.html">super_diag_tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.residual_tensor.html">residual_tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.generation.toeplitz_tensor.html">toeplitz_tensor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.utils.html#module-hottbox.utils.validation">Validation of N-dimensional arrays</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.validation.is_toeplitz_matrix.html">is_toeplitz_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.validation.is_super_symmetric.html">is_super_symmetric</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/generated/hottbox.utils.validation.is_toeplitz_tensor.html">is_toeplitz_tensor</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/hottbox.contrib.html">Experimental features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../api/hottbox.contrib.html#module-hottbox.contrib.visualisation">Visualisation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/hottbox.contrib.html#interactive-dashboards">Interactive dashboards</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../api/hottbox.contrib.html#helper-functions">Helper functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">HOTTBOX Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../changelog.html#hottbox-v0-2-2-unreleased">[HOTTBOX v0.2.2 Unreleased]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#package-status-on-branch-develop">Package status on branch <code class="docutils literal notranslate"><span class="pre">develop</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#added">Added</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#changed">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#removed">Removed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#fixed">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../changelog.html#hottbox-v0-2-1-2019-03-22">HOTTBOX v0.2.1 (2019-03-22)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#id1">Added</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../changelog.html#hottbox-v0-1-3">HOTTBOX v0.1.3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#id2">Added</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#id3">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#id4">Removed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#id5">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../changelog.html#hottbox-v0-1-2">HOTTBOX v0.1.2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#id6">Added</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#id7">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#id8">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../changelog.html#hottbox-v0-1-1">HOTTBOX v0.1.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../changelog.html#id9">Added</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../development_guide/index.html">Development guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../development_guide/how_to_contribute.html">How to contribute</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../development_guide/how_to_contribute.html#initial-setup-for-your-development">Initial setup for your development</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../development_guide/how_to_contribute.html#getting-up-to-date-with-the-main-project">Getting up to date with the main project</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../development_guide/before_pull_request.html">Before pull request</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../development_guide/before_pull_request.html#if-it-isnt-tested-its-broken">If it isn’t tested, it’s broken</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../development_guide/before_pull_request.html#document-your-code">Document your code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../development_guide/before_pull_request.html#docker-validation">Docker validation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../development_guide/general_guidelines_and_workflow.html">General guidelines and advices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../development_guide/general_guidelines_and_workflow.html#coding-guidelines">Coding guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../development_guide/general_guidelines_and_workflow.html#apis-of-hottbox-objects">APIs of hottbox objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../development_guide/general_guidelines_and_workflow.html#advised-git-branching-model">Advised git branching model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../development_guide/git_branching_model.html">Master branch</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../development_guide/git_branching_model.html#develop-branch">Develop branch</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../development_guide/git_branching_model.html#supporting-branches">Supporting branches</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../authors.html">Our Team</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">hottbox</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>hottbox.algorithms.classification.ensemble_learning</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
            
  <h1>Source code for hottbox.algorithms.classification.ensemble_learning</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="k">import</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">StratifiedShuffleSplit</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">accuracy_score</span>
<span class="kn">from</span> <span class="nn">...core.structures</span> <span class="k">import</span> <span class="n">BaseTensorTD</span><span class="p">,</span> <span class="n">TensorCPD</span><span class="p">,</span> <span class="n">TensorTKD</span>

<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">Classifier</span>


<span class="k">class</span> <span class="nc">BaseTensorEnsembleClassifier</span><span class="p">(</span><span class="n">Classifier</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is general interface for all classes that describe tensor ensemble learning algorithms.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -------</span>
<span class="sd">    base_clf : list[SklearnClassifier]</span>
<span class="sd">        List of classifiers</span>
<span class="sd">    probability : bool</span>
<span class="sd">        Whether to enable probability estimates. This must be enabled prior</span>
<span class="sd">        to calling `fit`, and will slow down that method.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Enable verbose output.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_clf</span><span class="p">,</span> <span class="n">probability</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_input_params</span><span class="p">(</span><span class="n">base_clf</span><span class="o">=</span><span class="n">base_clf</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync_base_clf_probability</span><span class="p">(</span><span class="n">base_clf</span><span class="o">=</span><span class="n">base_clf</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BaseTensorEnsembleClassifier</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span>
                                                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span> <span class="o">=</span> <span class="n">base_clf</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">self_as_string</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(base_clf=</span><span class="si">{}</span><span class="s2">, probability=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">name_base_clf</span><span class="p">,</span>
                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">probability</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self_as_string</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sync_base_clf_probability</span><span class="p">(</span><span class="n">base_clf</span><span class="p">,</span> <span class="n">probability</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Enable or disable probability estimation for the base classifiers</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base_clf : list[SklearnClassifier]</span>
<span class="sd">        probability : bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">clf</span> <span class="ow">in</span> <span class="n">base_clf</span><span class="p">:</span>
            <span class="c1"># clf.set_params(probability=probability)</span>
            <span class="c1"># Apparently, not all sklearn classes require to set probability  to `True`</span>
            <span class="c1"># TODO: throw a warning?</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">):</span>
                <span class="n">clf</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_input_params</span><span class="p">(</span><span class="n">base_clf</span><span class="p">,</span> <span class="n">probability</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Validate input parameters for the TEL constructor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base_clf : list[SklearnClassifier]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_clf</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input parameter `base_clf` should be a list&#39;</span><span class="p">)</span>

        <span class="c1"># Check that all base classifiers have required api</span>
        <span class="k">if</span> <span class="n">probability</span><span class="p">:</span>
            <span class="n">required_api</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fit&#39;</span><span class="p">,</span> <span class="s1">&#39;predict&#39;</span><span class="p">,</span> <span class="s1">&#39;predict_proba&#39;</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">required_api</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fit&#39;</span><span class="p">,</span> <span class="s1">&#39;predict&#39;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">clf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">base_clf</span><span class="p">):</span>
            <span class="n">all_attr</span> <span class="o">=</span> <span class="nb">dir</span><span class="p">(</span><span class="n">clf</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">required_api</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">all_attr</span><span class="p">):</span>
                <span class="n">missing_api</span> <span class="o">=</span> <span class="p">[</span><span class="n">api</span> <span class="k">for</span> <span class="n">api</span> <span class="ow">in</span> <span class="n">required_api</span> <span class="k">if</span> <span class="n">api</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_attr</span><span class="p">]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Base classifier #</span><span class="si">{}</span><span class="s1">: does not support required API (</span><span class="si">{}</span><span class="s1">)!!!</span><span class="se">\n</span><span class="s1">&#39;</span>
                                 <span class="s1">&#39;Missing methods are: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">required_api</span><span class="p">,</span> <span class="n">missing_api</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name_base_clf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get names of all employed base classifiers</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        names : list[str]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">clf</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">clf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">names</span>

    <span class="k">def</span> <span class="nf">get_params_base_clf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get parameters of an employed base classifier</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Specifies a base classifier which parameters are or interest</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        base_clf_params : dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_clf_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">base_clf_params</span>

    <span class="k">def</span> <span class="nf">set_params_base_clf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set parameters of an employed base classifier</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary with parameters for the base classifier</span>
<span class="sd">        i : int</span>
<span class="sd">            Specifies a base classifier for which the parameters are to be changed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Train all base classifiers at once</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : list[BaseTensorTD]</span>
<span class="sd">        y : np.ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp_to_array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">X_new</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X_list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_base_clf</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X_new</span><span class="p">,</span>
                              <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                              <span class="n">clf_num</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">fit_base_clf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">clf_num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Train specific base classifier</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray, shape = [n_samples, n_features]</span>
<span class="sd">            Training data, where n_samples is the number of samples and n_features is the number of features.</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Target relative to X for classification</span>
<span class="sd">        clf_num : int</span>
<span class="sd">            Positional number of the base classifier to be used</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Base classifier #</span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">): Learning model parameters&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">clf_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_base_clf</span><span class="p">[</span><span class="n">clf_num</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">[</span><span class="n">clf_num</span><span class="p">]</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">X_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp_to_array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">all_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_list</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">X_new</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X_list</span><span class="p">):</span>
            <span class="n">all_labels</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_base_clf</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X_new</span><span class="p">,</span>
                                                     <span class="n">clf_num</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># Find the most frequent values along each row of a matrix of labels from each base classifier</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_labels</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">,</span>
                                                 <span class="n">axis</span><span class="p">,</span>
                                                 <span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">all_labels</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                                 <span class="kc">None</span><span class="p">,</span>
                                                 <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                             <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
                             <span class="p">)]</span>
        <span class="k">return</span> <span class="n">y_pred</span>

    <span class="k">def</span> <span class="nf">predict_base_clf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">clf_num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform classification on samples in X on a specific base classifier</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray, shape = [n_samples, n_features]</span>
<span class="sd">            Test data, where n_samples is the number of samples and n_features is the number of features.</span>
<span class="sd">        clf_num : int</span>
<span class="sd">            Positional number of the base classifier is to be used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Class labels for samples in X.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">[</span><span class="n">clf_num</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">X_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp_to_array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">n_estimators</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_list</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">X_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">classes_</span><span class="o">.</span><span class="n">size</span>
        <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">X_new</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X_list</span><span class="p">):</span>
            <span class="n">y_pred_proba</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_proba_base_clf</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X_new</span><span class="p">,</span>
                                                        <span class="n">clf_num</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">y_pred_proba</span><span class="p">,</span> <span class="n">n_estimators</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred_proba</span>

    <span class="k">def</span> <span class="nf">predict_proba_base_clf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">clf_num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute probabilities of possible outcomes for samples in X on a specific base classifier</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray, shape = [n_samples, n_features]</span>
<span class="sd">            Test data, where n_samples is the number of samples and n_features is the number of features.</span>
<span class="sd">        clf_num : int</span>
<span class="sd">            Positional number of the base classifier is to be used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Returns the probability of the sample for each class in</span>
<span class="sd">            the model. The columns correspond to the classes in sorted</span>
<span class="sd">            order, as they appear in the attribute `base_clf[clf_num].classes_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_proba</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">[</span><span class="n">clf_num</span><span class="p">]</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the mean accuracy on the given test data and labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : list[BaseTensorTD]</span>
<span class="sd">        y : np.ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        acc = np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">probability</span><span class="p">:</span>
            <span class="n">pred_proba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proba_to_label</span><span class="p">(</span><span class="n">pred_proba</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">acc</span>

    <span class="k">def</span> <span class="nf">grid_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">search_params</span><span class="p">,</span> <span class="n">cv_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">search_params</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input parameter `search_params` should be a list of grid params&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">search_params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong number of searching params for the hyperparameter tuning of all base classifiers!!!</span><span class="se">\n</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> dicts of searching params are required, &#39;</span>
                             <span class="s1">&#39;whereas, </span><span class="si">{}</span><span class="s1"> dicts have been provided&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">search_params</span><span class="p">)))</span>
        <span class="n">X_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp_to_array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">best_params_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_new</span><span class="p">)):</span>
            <span class="n">best_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_search_base_clf</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X_new</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                    <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                                                    <span class="n">search_params</span><span class="o">=</span><span class="n">search_params</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                    <span class="n">clf_num</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                                                    <span class="n">cv_params</span><span class="o">=</span><span class="n">cv_params</span><span class="p">,</span>
                                                    <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                    <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">best_params_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">best_params_list</span>

    <span class="c1"># TODO: not sure whether default values is the good idea here</span>
    <span class="k">def</span> <span class="nf">grid_search_base_clf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">search_params</span><span class="p">,</span> <span class="n">clf_num</span><span class="p">,</span> <span class="n">cv_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform hyper parameter search with cross-validation for the specified base classifier.</span>
<span class="sd">        Parameter setting that gave the best results on the hold out data are assigned to this base classifier</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray, shape = [n_samples, n_features]</span>
<span class="sd">            Training data, where n_samples is the number of samples and n_features is the number of features.</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Target relative to X for classification</span>
<span class="sd">        search_params : dict</span>
<span class="sd">            Parameters names (string) as keys and lists of parameter settings to try as values</span>
<span class="sd">        clf_num : int</span>
<span class="sd">            Positional number of the base classifier which hyperparameters are to be tuned</span>
<span class="sd">        cv_params : dict</span>
<span class="sd">            Dictionary with kwargs that determine the cross-validation splitting strategy.</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, assign parameter setting that gave the best results on the hold out data to the base classifier</span>
<span class="sd">        n_jobs : int</span>
<span class="sd">            Number of jobs to run in parallel</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        dict</span>
<span class="sd">            Parameter setting that gave the best results on the hold out data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Base classifier #</span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">): Tuning the hyperparameters&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">clf_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_base_clf</span><span class="p">[</span><span class="n">clf_num</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">search_params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input parameter `search_params` should be a dict of parameters names (string) as keys &#39;</span>
                            <span class="s1">&#39;and lists of parameter settings to try as values&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cv_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Default parameters for cross-validation</span>
            <span class="n">cv_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">cv</span> <span class="o">=</span> <span class="n">StratifiedShuffleSplit</span><span class="p">(</span><span class="o">**</span><span class="n">cv_params</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">[</span><span class="n">clf_num</span><span class="p">],</span>
                            <span class="n">param_grid</span><span class="o">=</span><span class="n">search_params</span><span class="p">,</span>
                            <span class="n">cv</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span>
                            <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span>
                            <span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_params_base_clf</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">best_params_</span><span class="p">,</span> <span class="n">clf_num</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid</span><span class="o">.</span><span class="n">best_params_</span>

    <span class="k">def</span> <span class="nf">_decomp_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decomp_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Construct new datasets based on factor vectors of each tensor factorisation from the `decomp_list`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decomp_list : list[BaseTensorTD]</span>
<span class="sd">            List of tensor factorisations of all samples</span>

<span class="sd">        Notes</span>
<span class="sd">        -------</span>
<span class="sd">        This method should implement all manipulations with rearranging factor vectors. This should take into account</span>
<span class="sd">        the type of decomposition used prior the classification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not implemented in base (BaseEnsembleClassifier) class&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decomp_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decomp_list</span><span class="p">):</span>

        <span class="n">data_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decomp_to_array</span><span class="p">(</span><span class="n">decomp_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not enough base classifiers!!!</span><span class="se">\n</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;During object creation there had been specified </span><span class="si">{}</span><span class="s1"> base classifiers.</span><span class="se">\n</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;Whereas </span><span class="si">{}</span><span class="s1"> base classifiers are required for the </span><span class="si">{}</span><span class="s1"> classifier.&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                             <span class="p">)</span>
        <span class="k">return</span> <span class="n">data_list</span>

    <span class="k">def</span> <span class="nf">_proba_to_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pred_proba</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Assign label with respect to the highest probability among all classes in the model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pred_proba : np.ndarray</span>
<span class="sd">            Output of the self.predict_proba(). That is: probability of the sample for each class in the model.</span>
<span class="sd">            The columns correspond to the classes in sorted order, as they appear in the attribute</span>
<span class="sd">            `base_clf[i].classes_`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_pred : np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">pred_proba</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">classes_</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">idxmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">y_pred</span>

    <span class="c1"># Hacky way of getting predict_proba to raise an AttributeError when</span>
    <span class="c1"># probability=False using properties. Do not use this in new code; when</span>
    <span class="c1"># probabilities are not available depending on a setting, introduce two</span>
    <span class="c1"># estimators.</span>
    <span class="k">def</span> <span class="nf">_check_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">probability</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;`predict_proba` is not available when `probability=False`&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="TelVI"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVI.html#hottbox.algorithms.classification.TelVI">[docs]</a><span class="k">class</span> <span class="nc">TelVI</span><span class="p">(</span><span class="n">BaseTensorEnsembleClassifier</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Tensor Ensemble Learning: Vectors Independently (TelVI)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base_clf : list[SklearnClassifier]</span>
<span class="sd">        List of classifiers that will be used for the corresponding collection of the factor vectors of the tensor</span>
<span class="sd">        decomposition. This list does not have to be heterogeneous. However, all classifiers should support sklearn API.</span>
<span class="sd">        Length of this list should be equal to the number of collection of the factor vectors, otherwise an exception</span>
<span class="sd">        will be thrown. This is checked after the data have been splitted inside `decomp_to_array` method (called from</span>
<span class="sd">        `fit`, `predict`, `predict_proba`, `grid_search_base_clf`)</span>
<span class="sd">    probability : bool</span>
<span class="sd">        Whether to enable probability estimates. This must be enabled prior</span>
<span class="sd">        to calling `fit`, and will slow down that method.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Enable verbose output.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    ..  [1] Ilia Kisil, Ahmad Moniri, Danilo P. Mandic. &quot;Tensor Ensemble Learning for Multidimensional Data.&quot;</span>
<span class="sd">        In 2018 IEEE Global Conference on Signal and Information Processing (GlobalSIP), pp. 1358-1362. IEEE, 2018.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_clf</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TelVI</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base_clf</span><span class="o">=</span><span class="n">base_clf</span><span class="p">,</span>
                                    <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="TelVI.get_params_base_clf"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVI.html#hottbox.algorithms.classification.TelVI.get_params_base_clf">[docs]</a>    <span class="k">def</span> <span class="nf">get_params_base_clf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get parameters of employed base classifier</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Positional number of the base classifier. By default outputs parameters for all base classifiers</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[list[dict], dict]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">super</span><span class="p">(</span><span class="n">TelVI</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_params_base_clf</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">clf_num</span><span class="p">)</span> <span class="k">for</span> <span class="n">clf_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVI</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_params_base_clf</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="TelVI.set_params_base_clf"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVI.html#hottbox.algorithms.classification.TelVI.set_params_base_clf">[docs]</a>    <span class="k">def</span> <span class="nf">set_params_base_clf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set parameters for the specified base classifier</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Positional number of the base classifier.</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary with parameters for the base classifier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TelVI</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_params_base_clf</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                                               <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="TelVI.fit"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVI.html#hottbox.algorithms.classification.TelVI.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Fit specified classification models according to the given training data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {list[TensorCPD], list[TensorTKD]}</span>
<span class="sd">            List of training samples each of which is represented through a tensor factorisation</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Target relative to X for classification</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TelVI</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
                               <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="TelVI.predict"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVI.html#hottbox.algorithms.classification.TelVI.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform classification on samples in X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {list[TensorCPD], list[TensorTKD]}</span>
<span class="sd">            List of training samples each of which is represented through a tensor factorisation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_pred : np.ndarray</span>
<span class="sd">            Class labels for samples in X.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVI</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred</span></div>

<div class="viewcode-block" id="TelVI.predict_proba"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVI.html#hottbox.algorithms.classification.TelVI.predict_proba">[docs]</a>    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute probabilities of possible outcomes for samples in X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {list[TensorCPD], list[TensorTKD]}</span>
<span class="sd">            List of training samples each of which is represented through a tensor factorisation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_pred_proba : np.ndarray</span>
<span class="sd">            Returns the probability of the sample for each class in</span>
<span class="sd">            the model. The columns correspond to the classes in sorted</span>
<span class="sd">            order, as they appear in the attribute `base_clf[i].classes_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVI</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred_proba</span></div>

<div class="viewcode-block" id="TelVI.score"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVI.html#hottbox.algorithms.classification.TelVI.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVI</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">acc</span></div>

<div class="viewcode-block" id="TelVI.grid_search"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVI.html#hottbox.algorithms.classification.TelVI.grid_search">[docs]</a>    <span class="k">def</span> <span class="nf">grid_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">search_params</span><span class="p">,</span> <span class="n">cv_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform hyper parameter search with cross-validation for all base classifiers. Parameter setting that gave</span>
<span class="sd">        the best results on the hold out data are assigned to the base classifiers</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {list[TensorCPD], list[TensorTKD]}</span>
<span class="sd">            List of training samples each of which is represented through a tensor factorisation</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Target relative to X for classification</span>
<span class="sd">        search_params : list[dict]</span>
<span class="sd">            List of dictionaries with parameters names (string) as keys and lists of parameter settings to try as values</span>
<span class="sd">        cv_params : dict</span>
<span class="sd">            Dictionary with kwargs that determine the cross-validation splitting strategy.</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, assign parameter setting that gave the best results on the hold out data to the base classifier</span>
<span class="sd">        n_jobs : int</span>
<span class="sd">            Number of jobs to run in parallel</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_params : list[dict]</span>
<span class="sd">            List of parameter setting that gave the best results on the hold out data for the corresponding classifier</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the searching parameters are not provided as a list</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the searching parameters are not provided for each of the base classifier (lists length comparison)</span>
<span class="sd">            Note: All elements of `search_params` must contain only valid parameters for the respective base classifiers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">best_params</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVI</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">grid_search</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
                                                     <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                                                     <span class="n">search_params</span><span class="o">=</span><span class="n">search_params</span><span class="p">,</span>
                                                     <span class="n">cv_params</span><span class="o">=</span><span class="n">cv_params</span><span class="p">,</span>
                                                     <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                     <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">best_params</span></div>

    <span class="k">def</span> <span class="nf">decomp_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decomp_list</span><span class="p">):</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVI</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">decomp_to_array</span><span class="p">(</span><span class="n">decomp_list</span><span class="o">=</span><span class="n">decomp_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_list</span>

    <span class="k">def</span> <span class="nf">_decomp_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decomp_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Combine respective column vectors of factor matrices for all tensor factorisations.</span>

<span class="sd">        Each factor vector is treated as sample. Corresponding factor matrices should be of the same shape</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decomp_list : {list[TensorCPD], list[TensorTKD]}</span>
<span class="sd">            List of tensor factorisations of all samples</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_list : list[np.ndarray]</span>

<span class="sd">        Notes</span>
<span class="sd">        -------</span>
<span class="sd">        Each element of the `decomp_list` is the tensor factorisation of a sample. We do unfolding of tensor</span>
<span class="sd">        factorisation, i.e. unfold each factor matrix and stack them together in a long row vector. Then we stack these</span>
<span class="sd">        vectors into a matrix [sample \\times tensor features]. Then split this matrix in accordance with the lengths of</span>
<span class="sd">        factor vectors of the original decomposition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sample_decomp</span> <span class="o">=</span> <span class="n">decomp_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">fmat</span> <span class="ow">in</span> <span class="n">sample_decomp</span><span class="o">.</span><span class="n">fmat</span><span class="p">:</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">fmat</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>  <span class="c1"># Transpose is crucial</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">row</span>

        <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">decomp_list</span><span class="p">)):</span>
            <span class="n">sample_decomp</span> <span class="o">=</span> <span class="n">decomp_list</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">fmat</span> <span class="ow">in</span> <span class="n">sample_decomp</span><span class="o">.</span><span class="n">fmat</span><span class="p">:</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">fmat</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>  <span class="c1"># Transpose is crucial</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span>

        <span class="c1"># Create list of column indices for splitting different factor vectors</span>
        <span class="n">split_idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># this is the offset for the first split index</span>
        <span class="k">for</span> <span class="n">fmat</span> <span class="ow">in</span> <span class="n">sample_decomp</span><span class="o">.</span><span class="n">fmat</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">fmat</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">split_idx</span> <span class="o">=</span> <span class="n">split_idx</span> <span class="o">+</span> <span class="p">[</span><span class="n">split_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="c1"># Don&#39;t need the last index in order to avoid an empty element when np.hsplit is called</span>
        <span class="n">split_idx</span> <span class="o">=</span> <span class="n">split_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">split_idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_list</span></div>


<div class="viewcode-block" id="TelVAC"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVAC.html#hottbox.algorithms.classification.TelVAC">[docs]</a><span class="k">class</span> <span class="nc">TelVAC</span><span class="p">(</span><span class="n">BaseTensorEnsembleClassifier</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_clf</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TelVAC</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base_clf</span><span class="o">=</span><span class="n">base_clf</span><span class="p">,</span>
                                     <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="TelVAC.get_params_base_clf"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVAC.html#hottbox.algorithms.classification.TelVAC.get_params_base_clf">[docs]</a>    <span class="k">def</span> <span class="nf">get_params_base_clf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get parameters of employed base classifier</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Positional number of the base classifier. By default outputs parameters for all base classifiers</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[list[dict], dict]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">super</span><span class="p">(</span><span class="n">TelVAC</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_params_base_clf</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">clf_num</span><span class="p">)</span> <span class="k">for</span> <span class="n">clf_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_clf</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVAC</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_params_base_clf</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="TelVAC.set_params_base_clf"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVAC.html#hottbox.algorithms.classification.TelVAC.set_params_base_clf">[docs]</a>    <span class="k">def</span> <span class="nf">set_params_base_clf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set parameters for the specified base classifier</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Positional number of the base classifier.</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary with parameters for the base classifier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TelVAC</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_params_base_clf</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                                                <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="TelVAC.fit"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVAC.html#hottbox.algorithms.classification.TelVAC.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Fit specified classification models according to the given training data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : list[BaseTensorTD]</span>
<span class="sd">            List of training samples each of which is represented through a tensor factorisation</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Target relative to X for classification</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TelVAC</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
                                <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="TelVAC.predict"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVAC.html#hottbox.algorithms.classification.TelVAC.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform classification on samples in X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : list[BaseTensorTD]</span>
<span class="sd">            List of training samples each of which is represented through a tensor factorisation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_pred : np.ndarray</span>
<span class="sd">            Class labels for samples in X.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVAC</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred</span></div>

<div class="viewcode-block" id="TelVAC.predict_proba"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVAC.html#hottbox.algorithms.classification.TelVAC.predict_proba">[docs]</a>    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute probabilities of possible outcomes for samples in X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : list[BaseTensorTD]</span>
<span class="sd">            List of training samples each of which is represented through a tensor factorisation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y_pred_proba : np.ndarray</span>
<span class="sd">            Returns the probability of the sample for each class in</span>
<span class="sd">            the model. The columns correspond to the classes in sorted</span>
<span class="sd">            order, as they appear in the attribute `base_clf[i].classes_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_pred_proba</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVAC</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred_proba</span></div>

<div class="viewcode-block" id="TelVAC.score"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVAC.html#hottbox.algorithms.classification.TelVAC.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVAC</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">acc</span></div>

<div class="viewcode-block" id="TelVAC.grid_search"><a class="viewcode-back" href="../../../../api/generated/hottbox.algorithms.classification.TelVAC.html#hottbox.algorithms.classification.TelVAC.grid_search">[docs]</a>    <span class="k">def</span> <span class="nf">grid_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">search_params</span><span class="p">,</span> <span class="n">cv_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform hyper parameter search with cross-validation for all base classifiers.</span>

<span class="sd">        Parameter setting that gave the best results on the hold out data are assigned to the base classifiers</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : list[BaseTensorTD]</span>
<span class="sd">            List of training samples each of which is represented through a tensor factorisation</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Target relative to X for classification</span>
<span class="sd">        search_params : list[dict]</span>
<span class="sd">            List of dictionaries with parameters names (string) as keys and lists of parameter settings to try as values</span>
<span class="sd">        cv_params : dict</span>
<span class="sd">            Dictionary with kwargs that determine the cross-validation splitting strategy.</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, assign parameter setting that gave the best results on the hold out data to the base classifier</span>
<span class="sd">        n_jobs : int</span>
<span class="sd">            Number of jobs to run in parallel</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_params : list[dict]</span>
<span class="sd">            List of parameter setting that gave the best results on the hold out data for the corresponding classifier</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the searching parameters are not provided as a list</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the searching parameters are not provided for each of the base classifier (lists length comparison)</span>
<span class="sd">            Note: All elements of `search_params` must contain only valid parameters for the respective base classifiers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">best_params</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVAC</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">grid_search</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
                                                      <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                                                      <span class="n">search_params</span><span class="o">=</span><span class="n">search_params</span><span class="p">,</span>
                                                      <span class="n">cv_params</span><span class="o">=</span><span class="n">cv_params</span><span class="p">,</span>
                                                      <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                      <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">best_params</span></div>

    <span class="k">def</span> <span class="nf">decomp_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decomp_list</span><span class="p">):</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TelVAC</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">decomp_to_array</span><span class="p">(</span><span class="n">decomp_list</span><span class="o">=</span><span class="n">decomp_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_list</span>

    <span class="k">def</span> <span class="nf">_decomp_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decomp_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Combine column vectors of factor matrices for all tensor factorisations.</span>

<span class="sd">        Each combination belongs to different dataset.</span>
<span class="sd">        Each factor vector is treated as sample. Corresponding factor matrices should be of the same shape</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decomp_list : {list[TensorCPD], list[TensorTKD]}</span>
<span class="sd">            List of tensor factorisations of all samples</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_list : list[np.ndarray]</span>
<span class="sd">            List of new datasets of shape [n_samples, n_features]. Each sample is the combination of one factor vector</span>
<span class="sd">            from each of the factor matrices of the tensor factorisation for a given sample.</span>
<span class="sd">            len(data_list) = n_new_samples</span>
<span class="sd">            data_list[i].shape = [n_samples, n_new_features]</span>

<span class="sd">        Notes</span>
<span class="sd">        -------</span>
<span class="sd">        Each element of the `decomp_list` is a sample represented through a tensor factorisation. Each factor vector</span>
<span class="sd">        of each factor matrix of such decomposition is treated as a sample. Next we combine factor vectors from</span>
<span class="sd">        different factor matrices into a new sample by concatenating these factor vectors. Finally, we repeat this for</span>
<span class="sd">        each sample from the `decomp_list` and stack vertically the corresponding new samples.</span>

<span class="sd">        For each sample, the combination of vectors from several np.ndarrays is implemented as proposed in</span>
<span class="sd">        https://stackoverflow.com/a/47144986/6147064. This results in a matrix [n_new_samples, n_new_features].</span>
<span class="sd">        Next unfold this matrix into a row vector. Concatenated obtained rows for each sample from `decomp_list`.</span>
<span class="sd">        Finally, split the obtained array into a set of new datasets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sample_decomp</span> <span class="o">=</span> <span class="n">decomp_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Original sample_decomp.fmat[i] takes form [n_features, n_vectors], n_vectors are treated as samples</span>
        <span class="n">n_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">fmat</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">fmat</span> <span class="ow">in</span> <span class="n">sample_decomp</span><span class="o">.</span><span class="n">fmat</span><span class="p">]</span>  <span class="c1"># list of numbers of factor vectors (samples)</span>
        <span class="n">m_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">fmat</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">fmat</span> <span class="ow">in</span> <span class="n">sample_decomp</span><span class="o">.</span><span class="n">fmat</span><span class="p">]</span>  <span class="c1"># list of numbers of features in each factor vector</span>

        <span class="c1"># new number of samples (all combinations of all factor vectors from different factor matrices)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asscalar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">n_list</span><span class="p">)))</span>
        <span class="c1"># new number of features (sum of features in each )</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asscalar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m_list</span><span class="p">)))</span>

        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n_list</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">sample_decomp</span><span class="o">.</span><span class="n">fmat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose is crucial</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">sample_decomp</span><span class="o">.</span><span class="n">fmat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose is crucial</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">sample_decomp</span><span class="o">.</span><span class="n">fmat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose is crucial</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">A</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:],</span> <span class="n">B</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span> <span class="n">C</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">decomp_list</span><span class="p">)):</span>
            <span class="n">sample_decomp</span> <span class="o">=</span> <span class="n">decomp_list</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">sample_decomp</span><span class="o">.</span><span class="n">fmat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose is crucial</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">sample_decomp</span><span class="o">.</span><span class="n">fmat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose is crucial</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">sample_decomp</span><span class="o">.</span><span class="n">fmat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose is crucial</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">A</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:],</span> <span class="n">B</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span> <span class="n">C</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">temp</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>

        <span class="n">split_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rows</span><span class="o">*</span><span class="n">cols</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">split_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">data_list</span></div>
</pre></div>

           </div>
           
          </div>
    <a href="https://github.com/hottbox/hottbox">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub">
    </a>

          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017 - 2019, Ilya Kisil

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>